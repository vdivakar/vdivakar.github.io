<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://vdivakar.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://vdivakar.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-01-02T22:35:08+00:00</updated><id>https://vdivakar.github.io/feed.xml</id><title type="html">blank</title><subtitle>Portfolio website </subtitle><entry><title type="html">OpenAI Triton</title><link href="https://vdivakar.github.io/blog/2024/OpenAI-Triton/" rel="alternate" type="text/html" title="OpenAI Triton"/><published>2024-05-19T00:00:00+00:00</published><updated>2024-05-19T00:00:00+00:00</updated><id>https://vdivakar.github.io/blog/2024/OpenAI-Triton</id><content type="html" xml:base="https://vdivakar.github.io/blog/2024/OpenAI-Triton/"><![CDATA[<ol> <li><strong>Simple Vector addition</strong> <ul> <li>One limitation of Triton: <code class="language-plaintext highlighter-rouge">BLOCK_SIZE</code> must be a power-of-2</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="sh">'''</span><span class="s"> Simple Vector addition </span><span class="sh">'''</span>
 <span class="kn">import</span> <span class="n">torch</span>
 <span class="kn">import</span> <span class="n">triton</span>
 <span class="kn">import</span> <span class="n">triton.language</span> <span class="k">as</span> <span class="n">tl</span>

 <span class="nd">@triton.jit</span>
 <span class="k">def</span> <span class="nf">add_kernel</span><span class="p">(</span><span class="n">x_ptr</span><span class="p">,</span>
                <span class="n">y_ptr</span><span class="p">,</span>
                <span class="n">output_ptr</span><span class="p">,</span>
                <span class="n">n_elements</span><span class="p">,</span>
                <span class="n">BLOCK_SIZE</span><span class="p">:</span> <span class="n">tl</span><span class="p">.</span><span class="n">constexpr</span><span class="p">):</span> <span class="c1"># 'constexpr' so it can used as a shape value. ??
</span>        
     <span class="n">pid</span> <span class="o">=</span> <span class="n">tl</span><span class="p">.</span><span class="nf">program_id</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
     <span class="nf">print</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span> <span class="c1"># refer to image below for total number of prints
</span>
     <span class="n">block_start</span> <span class="o">=</span> <span class="n">pid</span> <span class="o">*</span> <span class="n">BLOCK_SIZE</span>
     <span class="n">offsets</span> <span class="o">=</span> <span class="n">tl</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">BLOCK_SIZE</span><span class="p">)</span>
     <span class="n">mask</span> <span class="o">=</span> <span class="n">block_start</span> <span class="o">+</span> <span class="n">offsets</span> <span class="o">&lt;</span> <span class="n">n_elements</span>

     <span class="n">x</span> <span class="o">=</span> <span class="n">tl</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">x_ptr</span> <span class="o">+</span> <span class="n">block_start</span> <span class="o">+</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
     <span class="n">y</span> <span class="o">=</span> <span class="n">tl</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="n">y_ptr</span> <span class="o">+</span> <span class="n">block_start</span> <span class="o">+</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
     <span class="n">output</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
     <span class="n">tl</span><span class="p">.</span><span class="nf">store</span><span class="p">(</span><span class="n">output_ptr</span> <span class="o">+</span> <span class="n">block_start</span> <span class="o">+</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

 <span class="n">size</span> <span class="o">=</span> <span class="mi">10</span>
 <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="sh">'</span><span class="s">cuda</span><span class="sh">'</span><span class="p">)</span>
 <span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="sh">'</span><span class="s">cuda</span><span class="sh">'</span><span class="p">)</span>
 <span class="n">output</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

 <span class="c1"># grid = lambda meta : (tl.cdiv(size, meta['BLOCK_SIZE']), ) # Error: cannot call @triton.jit'd outside of the scope of a kernel
</span>                                                              <span class="c1"># tl.cdiv cannot be compiled outside the kernel without @triton.jit
</span> <span class="n">grid</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">meta</span> <span class="p">:</span> <span class="p">(</span><span class="n">triton</span><span class="p">.</span><span class="nf">cdiv</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="sh">'</span><span class="s">BLOCK_SIZE</span><span class="sh">'</span><span class="p">]),</span> <span class="p">)</span>
 <span class="n">add_kernel</span><span class="p">[</span><span class="n">grid</span><span class="p">](</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">BLOCK_SIZE</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">num_warps</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

 <span class="nf">print</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

</code></pre></div> </div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">pid: </span><span class="sh">"</span><span class="p">,</span> <span class="n">pid</span><span class="p">)</span>

 <span class="c1"># Total number of programs = 3
</span> <span class="c1"># Each program will be printed: num_warps * warp_size
</span> <span class="c1"># Total number of prints: num_programs * (num_warps * warp_size)
</span></code></pre></div> </div> <p>Vector add illustration:</p> </li> </ol> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/openAI-Triton/vector_add-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/openAI-Triton/vector_add-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/openAI-Triton/vector_add-1400.webp"/> <img src="/assets/img/openAI-Triton/vector_add.jpg" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="vector_add image" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <ol> <li><strong>Simple Matrix Multiplication</strong> <ul> <li>4x4 Matrix: <code class="language-plaintext highlighter-rouge">tl.arange(0,4)[:, None] + tl.arange(0,4)[None, :]</code></li> </ul> </li> </ol> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/openAI-Triton/matmul-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/openAI-Triton/matmul-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/openAI-Triton/matmul-1400.webp"/> <img src="/assets/img/openAI-Triton/matmul.jpeg" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="vector_add image" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/openAI-Triton/stride-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/openAI-Triton/stride-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/openAI-Triton/stride-1400.webp"/> <img src="/assets/img/openAI-Triton/stride.jpeg" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="vector_add image" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <ol> <li>Que: How to print tensor’s shape from inside the triton kernel?</li> </ol>]]></content><author><name></name></author><summary type="html"><![CDATA[Triton language]]></summary></entry><entry><title type="html">Notes uncategorized</title><link href="https://vdivakar.github.io/blog/2024/Notes-uncategorised/" rel="alternate" type="text/html" title="Notes uncategorized"/><published>2024-04-20T00:00:00+00:00</published><updated>2024-04-20T00:00:00+00:00</updated><id>https://vdivakar.github.io/blog/2024/Notes-uncategorised</id><content type="html" xml:base="https://vdivakar.github.io/blog/2024/Notes-uncategorised/"><![CDATA[<ol> <li>f-string printing with ‘=’: <ul> <li>No need to write var name &amp; value separately <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">log_prob</span> <span class="o">=</span> <span class="o">-</span><span class="mf">3.141</span>
 <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">log_prob</span><span class="o">=</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>  <span class="c1"># log_prob= -3.141
</span></code></pre></div> </div> </li> </ul> </li> <li>plt.imshow(your_2d_matrix)</li> <li></li> </ol>]]></content><author><name></name></author><summary type="html"><![CDATA[self-notes. Random/cool stuff encountered.]]></summary></entry><entry><title type="html">Notes CUDA</title><link href="https://vdivakar.github.io/blog/2022/Notes-CUDA/" rel="alternate" type="text/html" title="Notes CUDA"/><published>2022-12-11T00:00:00+00:00</published><updated>2022-12-11T00:00:00+00:00</updated><id>https://vdivakar.github.io/blog/2022/Notes-CUDA</id><content type="html" xml:base="https://vdivakar.github.io/blog/2022/Notes-CUDA/"><![CDATA[<p>Notes for CUDA</p> <ol> <li>Setting grid and block dimensions <ul> <li>Un-initialized dimension (.x, .y, .z) is set to 1 by default. <pre><code class="language-C++"> dim3 grid (1024, 8);
 dim3 block (512, 1);
 myKernel&lt;&lt;&lt;grid, block&gt;&gt;&gt;(d_data);
</code></pre> </li> </ul> </li> <li>Don’t do this: <pre><code class="language-C++"> dim3 grid = (1024, 8); // !!!! Wrongly initialised values!!!!
</code></pre> </li> <li>Max of threads in a cuda block: 1024 <ul> <li>This is the total number of threads, not per dimension!</li> </ul> </li> <li>GPU -&gt; many Streaming Multiprocessors (SMs) -&gt; each with a control, Memory and many Cores <ul> <li>Each ThreadBlock is assigned (fully) to one of the SMs i.e. all the threads in a ThreadBlock go to the same SM</li> <li>Threads in the same ThreadBlock can collaborate with each other: <ul> <li>Barrier synchronization: __syncthreads()</li> <li>Shared memory</li> </ul> </li> <li>Threads in different blocks don’t synchronize. <ul> <li>Hence, blocks can execute in any order say, sequentially or parallely w.r.t each other</li> <li>Hence, same code can run on a different hardware with few or more SMs accordingly.</li> </ul> </li> </ul> </li> </ol>]]></content><author><name></name></author><summary type="html"><![CDATA[self-notes]]></summary></entry><entry><title type="html">Notes C++</title><link href="https://vdivakar.github.io/blog/2022/Notes-Cpp/" rel="alternate" type="text/html" title="Notes C++"/><published>2022-07-17T00:00:00+00:00</published><updated>2022-07-17T00:00:00+00:00</updated><id>https://vdivakar.github.io/blog/2022/Notes-Cpp</id><content type="html" xml:base="https://vdivakar.github.io/blog/2022/Notes-Cpp/"><![CDATA[<p>Notes for C++</p> <ol> <li><code class="language-plaintext highlighter-rouge">push_back()</code> vs <code class="language-plaintext highlighter-rouge">emplace_back()</code> <ul> <li>copy vs move</li> <li>vec.insert({a, b}) vs vec.emplace(a, b)</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">const</code> vs <code class="language-plaintext highlighter-rouge">constexpr</code> <ul> <li><code class="language-plaintext highlighter-rouge">const</code> : could be compile-time or runtime constants</li> <li><code class="language-plaintext highlighter-rouge">constexpr</code> : enforces compile-time constants. Fxns might still be runtime, check next point.</li> <li>Any variable that should not be modifiable after initialization and whose initializer is known at compile-time should be declared as <code class="language-plaintext highlighter-rouge">constexpr</code>.</li> <li>Any variable that should not be modifiable after initialization and whose initializer is not known at compile-time should be declared as <code class="language-plaintext highlighter-rouge">const</code>.</li> <li><a href="learncpp.com">https://www.learncpp.com/cpp-tutorial/compile-time-constants-constant-expressions-and-constexpr/</a></li> <li>Don’t use <code class="language-plaintext highlighter-rouge">const</code> when passing by value.</li> <li>Don’t use <code class="language-plaintext highlighter-rouge">const</code> when returning by value.</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">constexpr</code> and <code class="language-plaintext highlighter-rouge">consteval</code>. <a href="https://www.learncpp.com/cpp-tutorial/constexpr-and-consteval-functions/">Link</a> <ul> <li><code class="language-plaintext highlighter-rouge">constexpr</code> <ul> <li>can be called by both compile-time and runtime functions.</li> <li>to ensure compile-time, capture the return value in a new constexpr variable.</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">consteval</code> : <strong>– C++20 –</strong> <ul> <li>cannot be called during runtime</li> <li>enforces compile-time call. Parameters should be constexpr.</li> </ul> </li> </ul> </li> <li>Lambda <ul> <li></li> </ul> </li> <li>Variable initialisation. <ul> <li>3 ways: <ul> <li><strong>Copy</strong> (<code class="language-plaintext highlighter-rouge">=</code>) : Copy values.</li> <li><strong>Direct</strong> (<code class="language-plaintext highlighter-rouge">()</code>) : Direct initializer.</li> <li><strong>Brace</strong> (<code class="language-plaintext highlighter-rouge">{}</code>) : Direct list initializer. <code class="language-plaintext highlighter-rouge">&lt;--- use this</code></li> </ul> </li> <li>Default value for uninitialised variable:</li> </ul> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>    <span class="c1">// bad: undetermined. could be anything.</span>
 <span class="kt">int</span> <span class="nf">b</span><span class="p">();</span>  <span class="c1">// bad: interpreted as a function. Will return true!</span>
 <span class="kt">int</span> <span class="n">c</span><span class="p">{};</span>  <span class="c1">// good: init to 0</span>
 <span class="kt">int</span> <span class="n">d</span><span class="p">{</span><span class="mf">4.5</span><span class="p">};</span> <span class="c1">// [error][but safer]. {} doesn't allow value which d can't hold. Doesn't drop '.5' automatically like other 2 methods</span>
 <span class="n">string</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// empty string of size 0 i.e. s = ""</span>
</code></pre></div> </div> </li> <li>Postfix operator has higher precedence than prefix operator. <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="o">*</span><span class="n">ptr</span><span class="o">++</span> <span class="c1">// increment ptr but deref the un-incremented address</span>
</code></pre></div> </div> </li> <li>Operators which are mainly used for their ‘side effects’ return their <strong>left operand</strong>. This allows chaining. <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// evaluates as x = (y = 5)</span>
 <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello "</span> <span class="o">&lt;&lt;</span> <span class="s">"world"</span><span class="p">;</span> <span class="c1">// evaluates as (std::cout &lt;&lt; "Hello ") &lt;&lt; "world!"</span>
</code></pre></div> </div> </li> <li>Macros are bad: <ul> <li>Can’t be treated as normal variables. So, hard time to debug with debuggers; would see the name &amp; not the actual value. Debuggers ‘watch’ these variables.</li> <li>Don’t follow normal scoping rules; might end up getting used somewhere in the code!</li> <li>Risk of a variable being defined as a macro in some file.</li> </ul> </li> <li>Vector <code class="language-plaintext highlighter-rouge">reserve()</code> vs <code class="language-plaintext highlighter-rouge">resize()</code> vs nothing!: <ul> <li><code class="language-plaintext highlighter-rouge">reserve</code> would allocate memory ahead of time. <strong>Capacity</strong> will be affected, not size.</li> <li><code class="language-plaintext highlighter-rouge">resize</code> would insert or delete elements. <strong>Size</strong> is affected. Capacity may not be if new size &lt;= old capacity.</li> <li>nothing would grow/double the vector when size&gt;capacity. Required O(N) copying everytime!!</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">lvalue</code> vs <code class="language-plaintext highlighter-rouge">rvalue</code>: <ul> <li><code class="language-plaintext highlighter-rouge">lvalues</code> : variables/objects that persist beyond the end of the expression.</li> <li><code class="language-plaintext highlighter-rouge">rvalues</code> : literals or returned value of functions/operators that are discarded at the end of expression.</li> </ul> </li> <li>pointers(*) vs reference(&amp;): <a href="https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable?page=1&amp;tab=scoredesc#tab-top">Great answer link</a> <ul> <li>pointer: First account forwarding to second account. The pointer itself has a memory location. <ul> <li>name1@email.com -&gt; name_surname@email.com</li> </ul> </li> <li>reference: <strong>Alias</strong> of email. Both are same account; no separate memory. <ul> <li>netID@uni.com, first.last@uni.com</li> <li>has to be initialised. can’t be reseated.</li> </ul> </li> </ul> </li> <li>L-value reference with <code class="language-plaintext highlighter-rouge">const</code>: <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span> <span class="p">{</span> <span class="mi">50</span> <span class="p">};</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">y</span> <span class="p">{</span><span class="mi">100</span><span class="p">};</span>

<span class="kt">int</span><span class="o">&amp;</span> <span class="n">ref</span> <span class="p">{</span> <span class="n">x</span> <span class="p">};</span>           <span class="c1">// valid: lvalue reference bound to a modifiable lvalue</span>
<span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">const_ref</span> <span class="p">{</span><span class="n">x</span><span class="p">};</span> <span class="c1">// still valid</span>

<span class="c1">// const_ref = 51 // invalid: can't change through const reference.</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">51</span><span class="p">;</span>           <span class="c1">// valid: can be changed through non-const identifier </span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&lt;&lt;</span> <span class="n">ref</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">const_ref</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 51 51</span>

<span class="kt">int</span><span class="o">&amp;</span> <span class="n">ref_y</span> <span class="p">{</span> <span class="n">y</span> <span class="p">};</span>           <span class="c1">// invalid: can't bind to a non-modifiable lvalue</span>
<span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">ref_y_const</span> <span class="p">{</span><span class="n">y</span><span class="p">};</span> <span class="c1">// valid</span>

<span class="kt">int</span><span class="o">&amp;</span> <span class="n">ref_rvalue</span> <span class="p">{</span><span class="mi">1</span><span class="p">};</span>        <span class="c1">// invalid: can't bind to an r-value. Else you'll try to modify 1 using the reference</span>
<span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">ref_rvalue2</span> <span class="p">{</span><span class="mi">1</span><span class="p">};</span> <span class="c1">// valid: temporary object of rvalue is created.</span>
</code></pre></div> </div> </li> <li><code class="language-plaintext highlighter-rouge">const</code> ptr : <a href="https://compiler-explorer.com/z/o716TG8oo">compiler-explorer link</a> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">const</span> <span class="n">MyClass</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">obj</span><span class="p">;</span>
    <span class="n">MyClass</span><span class="o">*</span> <span class="k">const</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">obj</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">MyClass</span><span class="o">*</span> <span class="k">const</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">obj</span><span class="p">;</span> <span class="c1">//read-only</span>
</code></pre></div> </div> </li> <li><code class="language-plaintext highlighter-rouge">unique_ptr</code> and <code class="language-plaintext highlighter-rouge">shared_ptr</code>: <ul> <li>unique_ptr</li> <li>shared_ptr : multiple smart pointers share the same resource. Resource is deallocated when the last smart ptr goes out of scope (count==0) <ul> <li>uses reference counting for control block.</li> <li>prefer make_shared. Combines resource + control into a sigle memory.</li> </ul> </li> </ul> </li> <li>Caution: <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">decimal</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">binary</span> <span class="o">=</span> <span class="mb">0b1010</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">hex</span> <span class="o">=</span> <span class="mh">0x1010</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">octal</span> <span class="o">=</span> <span class="mo">010</span><span class="p">;</span> <span class="c1">// &lt;-- prefix zero means Octal!!</span>
</code></pre></div> </div> </li> <li>Python-like bindings: <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="p">[</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">]</span><span class="o">:</span> <span class="n">my_map</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">key</span> <span class="o">&lt;&lt;</span> <span class="s">": "</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> </li> <li>Classes: <ul> <li><a href="https://compiler-explorer.com/z/oh434PqG9">Compiler Explorer code link</a></li> <li>Default access to members and methods is private</li> <li>classes with virtual functions maintain <em>vtbl (virtual function table)</em> to determine the function call</li> <li></li> </ul> </li> <li>Dynamic &amp; Static cast: <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span><span class="p">(</span><span class="n">TypeA</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">TypeA</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">)){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ptr is of TypeA"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">3.4</span><span class="p">);</span>
</code></pre></div> </div> </li> <li>Move vs Copy - <a href="https://godbolt.org/z/jvn9dd4Mq">Compiler Explorer, Quick C++ Benchmark</a></li> </ol>]]></content><author><name></name></author><summary type="html"><![CDATA[self-notes]]></summary></entry><entry><title type="html">H.O.M.L Ch-4 | Training models algo</title><link href="https://vdivakar.github.io/blog/2021/HOML-Ch4/" rel="alternate" type="text/html" title="H.O.M.L Ch-4 | Training models algo"/><published>2021-04-29T00:00:00+00:00</published><updated>2021-04-29T00:00:00+00:00</updated><id>https://vdivakar.github.io/blog/2021/HOML-Ch4</id><content type="html" xml:base="https://vdivakar.github.io/blog/2021/HOML-Ch4/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[Chapter summary of Hands on Machine Learning]]></summary></entry><entry><title type="html">MNIST Muddle</title><link href="https://vdivakar.github.io/blog/2021/MNIST-muddle/" rel="alternate" type="text/html" title="MNIST Muddle"/><published>2021-04-29T00:00:00+00:00</published><updated>2021-04-29T00:00:00+00:00</updated><id>https://vdivakar.github.io/blog/2021/MNIST-muddle</id><content type="html" xml:base="https://vdivakar.github.io/blog/2021/MNIST-muddle/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[Creating poorly written numeric digits using AutoEncoders and MNIST dataset.]]></summary></entry><entry><title type="html">Azure Cognitive services using Python &amp;amp; REST API | Text-to-Speech</title><link href="https://vdivakar.github.io/blog/2021/Azure-TTS/" rel="alternate" type="text/html" title="Azure Cognitive services using Python &amp;amp; REST API | Text-to-Speech"/><published>2021-04-06T00:00:00+00:00</published><updated>2021-04-06T00:00:00+00:00</updated><id>https://vdivakar.github.io/blog/2021/Azure-TTS</id><content type="html" xml:base="https://vdivakar.github.io/blog/2021/Azure-TTS/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[How to use Microsoft's Text-to-Speech neural API to generate audios from text input.]]></summary></entry><entry><title type="html">H.O.M.L Chapter-3 | Classification</title><link href="https://vdivakar.github.io/blog/2021/HOML-Ch3/" rel="alternate" type="text/html" title="H.O.M.L Chapter-3 | Classification"/><published>2021-04-03T00:00:00+00:00</published><updated>2021-04-03T00:00:00+00:00</updated><id>https://vdivakar.github.io/blog/2021/HOML-Ch3</id><content type="html" xml:base="https://vdivakar.github.io/blog/2021/HOML-Ch3/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[Chapter summary of Hands on Machine Learning]]></summary></entry><entry><title type="html">H.O.M.L Chp-2 Summary | End-to-end ML Project</title><link href="https://vdivakar.github.io/blog/2021/HOML-Ch2/" rel="alternate" type="text/html" title="H.O.M.L Chp-2 Summary | End-to-end ML Project"/><published>2021-03-28T00:00:00+00:00</published><updated>2021-03-28T00:00:00+00:00</updated><id>https://vdivakar.github.io/blog/2021/HOML-Ch2</id><content type="html" xml:base="https://vdivakar.github.io/blog/2021/HOML-Ch2/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[Chapter summary of Hands on Machine Learning]]></summary></entry><entry><title type="html">H.O.M.L Chp-1 Summary | The ML Landscape</title><link href="https://vdivakar.github.io/blog/2021/HOML-Ch1/" rel="alternate" type="text/html" title="H.O.M.L Chp-1 Summary | The ML Landscape"/><published>2021-03-27T00:00:00+00:00</published><updated>2021-03-27T00:00:00+00:00</updated><id>https://vdivakar.github.io/blog/2021/HOML-Ch1</id><content type="html" xml:base="https://vdivakar.github.io/blog/2021/HOML-Ch1/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[Chapter summary of Hands on Machine Learning]]></summary></entry></feed>